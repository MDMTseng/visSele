
/* This file is generated by glib-mkenums, do not modify it. This code is licensed under the same license as the containing project. Note that it links to GLib, so must comply with the LGPL linking clauses. */

#include "arvenumtypesprivate.h"
#include "arvbufferprivate.h"
#include "arvchunkparserprivate.h"
#include "arvdebugprivate.h"
#include "arvdeviceprivate.h"
#include "arvfakedeviceprivate.h"
#include "arvfakeinterfaceprivate.h"
#include "arvfakestreamprivate.h"
#include "arvgcprivate.h"
#include "arvgcconverterprivate.h"
#include "arvgcdefaultsprivate.h"
#include "arvgcfeaturenodeprivate.h"
#include "arvgcregisternodeprivate.h"
#include "arvgcswissknifeprivate.h"
#include "arvgvcpprivate.h"
#include "arvgvdeviceprivate.h"
#include "arvgvinterfaceprivate.h"
#include "arvgvspprivate.h"
#include "arvgvstreamprivate.h"
#include "arvinterfaceprivate.h"
#include "arvmiscprivate.h"
#include "arvnetworkprivate.h"
#include "arvrealtimeprivate.h"
#include "arvstreamprivate.h"
#include "arvwakeupprivate.h"
#include "arvuvcpprivate.h"
#include "arvuvdeviceprivate.h"
#include "arvuvinterfaceprivate.h"
#include "arvuvstreamprivate.h"
#include "arvuvspprivate.h"

#define C_ENUM(v) ((gint) v)
#define C_FLAGS(v) ((guint) v)

/* enumerations from "arvdebugprivate.h" */

GType
arv_debug_level_get_type (void)
{
static gsize gtype_id = 0;
static const GEnumValue values[] = {
    { C_ENUM(ARV_DEBUG_LEVEL_NONE), "ARV_DEBUG_LEVEL_NONE", "none" },
    { C_ENUM(ARV_DEBUG_LEVEL_WARNING), "ARV_DEBUG_LEVEL_WARNING", "warning" },
    { C_ENUM(ARV_DEBUG_LEVEL_INFO), "ARV_DEBUG_LEVEL_INFO", "info" },
    { C_ENUM(ARV_DEBUG_LEVEL_DEBUG), "ARV_DEBUG_LEVEL_DEBUG", "debug" },
    { C_ENUM(ARV_DEBUG_LEVEL_TRACE), "ARV_DEBUG_LEVEL_TRACE", "trace" },
    { C_ENUM(ARV_DEBUG_LEVEL_N_ELEMENTS), "ARV_DEBUG_LEVEL_N_ELEMENTS", "n-elements" },
{ 0, NULL, NULL }
        };
        if (g_once_init_enter (&gtype_id)) {
            GType new_type = g_enum_register_static (g_intern_static_string ("ArvDebugLevel"), values);
            g_once_init_leave (&gtype_id, new_type);
        }
        return (GType) gtype_id;
        }

GType
arv_debug_category_get_type (void)
{
static gsize gtype_id = 0;
static const GEnumValue values[] = {
    { C_ENUM(ARV_DEBUG_CATEGORY_INTERFACE), "ARV_DEBUG_CATEGORY_INTERFACE", "interface" },
    { C_ENUM(ARV_DEBUG_CATEGORY_DEVICE), "ARV_DEBUG_CATEGORY_DEVICE", "device" },
    { C_ENUM(ARV_DEBUG_CATEGORY_STREAM), "ARV_DEBUG_CATEGORY_STREAM", "stream" },
    { C_ENUM(ARV_DEBUG_CATEGORY_STREAM_THREAD), "ARV_DEBUG_CATEGORY_STREAM_THREAD", "stream-thread" },
    { C_ENUM(ARV_DEBUG_CATEGORY_CP), "ARV_DEBUG_CATEGORY_CP", "cp" },
    { C_ENUM(ARV_DEBUG_CATEGORY_SP), "ARV_DEBUG_CATEGORY_SP", "sp" },
    { C_ENUM(ARV_DEBUG_CATEGORY_GENICAM), "ARV_DEBUG_CATEGORY_GENICAM", "genicam" },
    { C_ENUM(ARV_DEBUG_CATEGORY_POLICIES), "ARV_DEBUG_CATEGORY_POLICIES", "policies" },
    { C_ENUM(ARV_DEBUG_CATEGORY_CHUNK), "ARV_DEBUG_CATEGORY_CHUNK", "chunk" },
    { C_ENUM(ARV_DEBUG_CATEGORY_DOM), "ARV_DEBUG_CATEGORY_DOM", "dom" },
    { C_ENUM(ARV_DEBUG_CATEGORY_EVALUATOR), "ARV_DEBUG_CATEGORY_EVALUATOR", "evaluator" },
    { C_ENUM(ARV_DEBUG_CATEGORY_VIEWER), "ARV_DEBUG_CATEGORY_VIEWER", "viewer" },
    { C_ENUM(ARV_DEBUG_CATEGORY_MISC), "ARV_DEBUG_CATEGORY_MISC", "misc" },
    { C_ENUM(ARV_DEBUG_CATEGORY_N_ELEMENTS), "ARV_DEBUG_CATEGORY_N_ELEMENTS", "n-elements" },
{ 0, NULL, NULL }
        };
        if (g_once_init_enter (&gtype_id)) {
            GType new_type = g_enum_register_static (g_intern_static_string ("ArvDebugCategory"), values);
            g_once_init_leave (&gtype_id, new_type);
        }
        return (GType) gtype_id;
        }

/* enumerations from "arvgcconverterprivate.h" */

GType
arv_gc_converter_node_type_get_type (void)
{
static gsize gtype_id = 0;
static const GEnumValue values[] = {
    { C_ENUM(ARV_GC_CONVERTER_NODE_TYPE_VALUE), "ARV_GC_CONVERTER_NODE_TYPE_VALUE", "value" },
    { C_ENUM(ARV_GC_CONVERTER_NODE_TYPE_MIN), "ARV_GC_CONVERTER_NODE_TYPE_MIN", "min" },
    { C_ENUM(ARV_GC_CONVERTER_NODE_TYPE_MAX), "ARV_GC_CONVERTER_NODE_TYPE_MAX", "max" },
    { C_ENUM(ARV_GC_CONVERTER_NODE_TYPE_INC), "ARV_GC_CONVERTER_NODE_TYPE_INC", "inc" },
{ 0, NULL, NULL }
        };
        if (g_once_init_enter (&gtype_id)) {
            GType new_type = g_enum_register_static (g_intern_static_string ("ArvGcConverterNodeType"), values);
            g_once_init_leave (&gtype_id, new_type);
        }
        return (GType) gtype_id;
        }

/* enumerations from "arvgvcpprivate.h" */

GType
arv_gvcp_packet_type_get_type (void)
{
static gsize gtype_id = 0;
static const GEnumValue values[] = {
    { C_ENUM(ARV_GVCP_PACKET_TYPE_ACK), "ARV_GVCP_PACKET_TYPE_ACK", "ack" },
    { C_ENUM(ARV_GVCP_PACKET_TYPE_CMD), "ARV_GVCP_PACKET_TYPE_CMD", "cmd" },
    { C_ENUM(ARV_GVCP_PACKET_TYPE_ERROR), "ARV_GVCP_PACKET_TYPE_ERROR", "error" },
    { C_ENUM(ARV_GVCP_PACKET_TYPE_UNKNOWN_ERROR), "ARV_GVCP_PACKET_TYPE_UNKNOWN_ERROR", "unknown-error" },
{ 0, NULL, NULL }
        };
        if (g_once_init_enter (&gtype_id)) {
            GType new_type = g_enum_register_static (g_intern_static_string ("ArvGvcpPacketType"), values);
            g_once_init_leave (&gtype_id, new_type);
        }
        return (GType) gtype_id;
        }

GType
arv_gvcp_error_get_type (void)
{
static gsize gtype_id = 0;
static const GEnumValue values[] = {
    { C_ENUM(ARV_GVCP_ERROR_NONE), "ARV_GVCP_ERROR_NONE", "none" },
    { C_ENUM(ARV_GVCP_ERROR_NOT_IMPLEMENTED), "ARV_GVCP_ERROR_NOT_IMPLEMENTED", "not-implemented" },
    { C_ENUM(ARV_GVCP_ERROR_INVALID_PARAMETER), "ARV_GVCP_ERROR_INVALID_PARAMETER", "invalid-parameter" },
    { C_ENUM(ARV_GVCP_ERROR_INVALID_ACCESS), "ARV_GVCP_ERROR_INVALID_ACCESS", "invalid-access" },
    { C_ENUM(ARV_GVCP_ERROR_WRITE_PROTECT), "ARV_GVCP_ERROR_WRITE_PROTECT", "write-protect" },
    { C_ENUM(ARV_GVCP_ERROR_BAD_ALIGNMENT), "ARV_GVCP_ERROR_BAD_ALIGNMENT", "bad-alignment" },
    { C_ENUM(ARV_GVCP_ERROR_ACCESS_DENIED), "ARV_GVCP_ERROR_ACCESS_DENIED", "access-denied" },
    { C_ENUM(ARV_GVCP_ERROR_BUSY), "ARV_GVCP_ERROR_BUSY", "busy" },
    { C_ENUM(ARV_GVCP_ERROR_LOCAL_PROBLEM), "ARV_GVCP_ERROR_LOCAL_PROBLEM", "local-problem" },
    { C_ENUM(ARV_GVCP_ERROR_MESSAGE_MISMATCH), "ARV_GVCP_ERROR_MESSAGE_MISMATCH", "message-mismatch" },
    { C_ENUM(ARV_GVCP_ERROR_INVALID_PROTOCOL), "ARV_GVCP_ERROR_INVALID_PROTOCOL", "invalid-protocol" },
    { C_ENUM(ARV_GVCP_ERROR_NO_MESSAGE), "ARV_GVCP_ERROR_NO_MESSAGE", "no-message" },
    { C_ENUM(ARV_GVCP_ERROR_PACKET_UNAVAILABLE), "ARV_GVCP_ERROR_PACKET_UNAVAILABLE", "packet-unavailable" },
    { C_ENUM(ARV_GVCP_ERROR_DATA_OVERRUN), "ARV_GVCP_ERROR_DATA_OVERRUN", "data-overrun" },
    { C_ENUM(ARV_GVCP_ERROR_INVALID_HEADER), "ARV_GVCP_ERROR_INVALID_HEADER", "invalid-header" },
    { C_ENUM(ARV_GVCP_ERROR_WRONG_CONFIG), "ARV_GVCP_ERROR_WRONG_CONFIG", "wrong-config" },
    { C_ENUM(ARV_GVCP_ERROR_PACKET_NOT_YET_AVAILABLE), "ARV_GVCP_ERROR_PACKET_NOT_YET_AVAILABLE", "packet-not-yet-available" },
    { C_ENUM(ARV_GVCP_ERROR_PACKET_AND_PREVIOUS_REMOVED_FROM_MEMORY), "ARV_GVCP_ERROR_PACKET_AND_PREVIOUS_REMOVED_FROM_MEMORY", "packet-and-previous-removed-from-memory" },
    { C_ENUM(ARV_GVCP_ERROR_PACKET_REMOVED_FROM_MEMORY), "ARV_GVCP_ERROR_PACKET_REMOVED_FROM_MEMORY", "packet-removed-from-memory" },
    { C_ENUM(ARV_GVCP_ERROR_NO_REFERENCE_TIME), "ARV_GVCP_ERROR_NO_REFERENCE_TIME", "no-reference-time" },
    { C_ENUM(ARV_GVCP_ERROR_PACKET_TEMPORARILY_UNAVAILABLE), "ARV_GVCP_ERROR_PACKET_TEMPORARILY_UNAVAILABLE", "packet-temporarily-unavailable" },
    { C_ENUM(ARV_GVCP_ERROR_OVERFLOW), "ARV_GVCP_ERROR_OVERFLOW", "overflow" },
    { C_ENUM(ARV_GVCP_ERROR_ACTION_LATE), "ARV_GVCP_ERROR_ACTION_LATE", "action-late" },
    { C_ENUM(ARV_GVCP_ERROR_LEADER_TRAILER_OVERFLOW), "ARV_GVCP_ERROR_LEADER_TRAILER_OVERFLOW", "leader-trailer-overflow" },
    { C_ENUM(ARV_GVCP_ERROR_GENERIC), "ARV_GVCP_ERROR_GENERIC", "generic" },
{ 0, NULL, NULL }
        };
        if (g_once_init_enter (&gtype_id)) {
            GType new_type = g_enum_register_static (g_intern_static_string ("ArvGvcpError"), values);
            g_once_init_leave (&gtype_id, new_type);
        }
        return (GType) gtype_id;
        }

GType
arv_gvcp_cmd_packet_flags_get_type (void)
{
static gsize gtype_id = 0;
static const GEnumValue values[] = {
    { C_ENUM(ARV_GVCP_CMD_PACKET_FLAGS_NONE), "ARV_GVCP_CMD_PACKET_FLAGS_NONE", "none" },
    { C_ENUM(ARV_GVCP_CMD_PACKET_FLAGS_ACK_REQUIRED), "ARV_GVCP_CMD_PACKET_FLAGS_ACK_REQUIRED", "ack-required" },
    { C_ENUM(ARV_GVCP_CMD_PACKET_FLAGS_EXTENDED_IDS), "ARV_GVCP_CMD_PACKET_FLAGS_EXTENDED_IDS", "extended-ids" },
{ 0, NULL, NULL }
        };
        if (g_once_init_enter (&gtype_id)) {
            GType new_type = g_enum_register_static (g_intern_static_string ("ArvGvcpCmdPacketFlags"), values);
            g_once_init_leave (&gtype_id, new_type);
        }
        return (GType) gtype_id;
        }

GType
arv_gvcp_event_packet_flags_get_type (void)
{
static gsize gtype_id = 0;
static const GEnumValue values[] = {
    { C_ENUM(ARV_GVCP_EVENT_PACKET_FLAGS_NONE), "ARV_GVCP_EVENT_PACKET_FLAGS_NONE", "none" },
    { C_ENUM(ARV_GVCP_EVENT_PACKET_FLAGS_64BIT_ID), "ARV_GVCP_EVENT_PACKET_FLAGS_64BIT_ID", "64bit-id" },
{ 0, NULL, NULL }
        };
        if (g_once_init_enter (&gtype_id)) {
            GType new_type = g_enum_register_static (g_intern_static_string ("ArvGvcpEventPacketFlags"), values);
            g_once_init_leave (&gtype_id, new_type);
        }
        return (GType) gtype_id;
        }

GType
arv_gvcp_discovery_packet_flags_get_type (void)
{
static gsize gtype_id = 0;
static const GEnumValue values[] = {
    { C_ENUM(ARV_GVCP_DISCOVERY_PACKET_FLAGS_NONE), "ARV_GVCP_DISCOVERY_PACKET_FLAGS_NONE", "none" },
    { C_ENUM(ARV_GVCP_DISCOVERY_PACKET_FLAGS_ALLOW_BROADCAST_ACK), "ARV_GVCP_DISCOVERY_PACKET_FLAGS_ALLOW_BROADCAST_ACK", "allow-broadcast-ack" },
{ 0, NULL, NULL }
        };
        if (g_once_init_enter (&gtype_id)) {
            GType new_type = g_enum_register_static (g_intern_static_string ("ArvGvcpDiscoveryPacketFlags"), values);
            g_once_init_leave (&gtype_id, new_type);
        }
        return (GType) gtype_id;
        }

GType
arv_gvcp_command_get_type (void)
{
static gsize gtype_id = 0;
static const GEnumValue values[] = {
    { C_ENUM(ARV_GVCP_COMMAND_DISCOVERY_CMD), "ARV_GVCP_COMMAND_DISCOVERY_CMD", "discovery-cmd" },
    { C_ENUM(ARV_GVCP_COMMAND_DISCOVERY_ACK), "ARV_GVCP_COMMAND_DISCOVERY_ACK", "discovery-ack" },
    { C_ENUM(ARV_GVCP_COMMAND_BYE_CMD), "ARV_GVCP_COMMAND_BYE_CMD", "bye-cmd" },
    { C_ENUM(ARV_GVCP_COMMAND_BYE_ACK), "ARV_GVCP_COMMAND_BYE_ACK", "bye-ack" },
    { C_ENUM(ARV_GVCP_COMMAND_PACKET_RESEND_CMD), "ARV_GVCP_COMMAND_PACKET_RESEND_CMD", "packet-resend-cmd" },
    { C_ENUM(ARV_GVCP_COMMAND_PACKET_RESEND_ACK), "ARV_GVCP_COMMAND_PACKET_RESEND_ACK", "packet-resend-ack" },
    { C_ENUM(ARV_GVCP_COMMAND_READ_REGISTER_CMD), "ARV_GVCP_COMMAND_READ_REGISTER_CMD", "read-register-cmd" },
    { C_ENUM(ARV_GVCP_COMMAND_READ_REGISTER_ACK), "ARV_GVCP_COMMAND_READ_REGISTER_ACK", "read-register-ack" },
    { C_ENUM(ARV_GVCP_COMMAND_WRITE_REGISTER_CMD), "ARV_GVCP_COMMAND_WRITE_REGISTER_CMD", "write-register-cmd" },
    { C_ENUM(ARV_GVCP_COMMAND_WRITE_REGISTER_ACK), "ARV_GVCP_COMMAND_WRITE_REGISTER_ACK", "write-register-ack" },
    { C_ENUM(ARV_GVCP_COMMAND_READ_MEMORY_CMD), "ARV_GVCP_COMMAND_READ_MEMORY_CMD", "read-memory-cmd" },
    { C_ENUM(ARV_GVCP_COMMAND_READ_MEMORY_ACK), "ARV_GVCP_COMMAND_READ_MEMORY_ACK", "read-memory-ack" },
    { C_ENUM(ARV_GVCP_COMMAND_WRITE_MEMORY_CMD), "ARV_GVCP_COMMAND_WRITE_MEMORY_CMD", "write-memory-cmd" },
    { C_ENUM(ARV_GVCP_COMMAND_WRITE_MEMORY_ACK), "ARV_GVCP_COMMAND_WRITE_MEMORY_ACK", "write-memory-ack" },
    { C_ENUM(ARV_GVCP_COMMAND_PENDING_ACK), "ARV_GVCP_COMMAND_PENDING_ACK", "pending-ack" },
{ 0, NULL, NULL }
        };
        if (g_once_init_enter (&gtype_id)) {
            GType new_type = g_enum_register_static (g_intern_static_string ("ArvGvcpCommand"), values);
            g_once_init_leave (&gtype_id, new_type);
        }
        return (GType) gtype_id;
        }

/* enumerations from "arvgvspprivate.h" */

GType
arv_gvsp_packet_type_get_type (void)
{
static gsize gtype_id = 0;
static const GEnumValue values[] = {
    { C_ENUM(ARV_GVSP_PACKET_TYPE_OK), "ARV_GVSP_PACKET_TYPE_OK", "ok" },
    { C_ENUM(ARV_GVSP_PACKET_TYPE_RESEND), "ARV_GVSP_PACKET_TYPE_RESEND", "resend" },
    { C_ENUM(ARV_GVSP_PACKET_TYPE_PACKET_UNAVAILABLE), "ARV_GVSP_PACKET_TYPE_PACKET_UNAVAILABLE", "packet-unavailable" },
{ 0, NULL, NULL }
        };
        if (g_once_init_enter (&gtype_id)) {
            GType new_type = g_enum_register_static (g_intern_static_string ("ArvGvspPacketType"), values);
            g_once_init_leave (&gtype_id, new_type);
        }
        return (GType) gtype_id;
        }

GType
arv_gvsp_content_type_get_type (void)
{
static gsize gtype_id = 0;
static const GEnumValue values[] = {
    { C_ENUM(ARV_GVSP_CONTENT_TYPE_DATA_LEADER), "ARV_GVSP_CONTENT_TYPE_DATA_LEADER", "data-leader" },
    { C_ENUM(ARV_GVSP_CONTENT_TYPE_DATA_TRAILER), "ARV_GVSP_CONTENT_TYPE_DATA_TRAILER", "data-trailer" },
    { C_ENUM(ARV_GVSP_CONTENT_TYPE_DATA_BLOCK), "ARV_GVSP_CONTENT_TYPE_DATA_BLOCK", "data-block" },
    { C_ENUM(ARV_GVSP_CONTENT_TYPE_ALL_IN), "ARV_GVSP_CONTENT_TYPE_ALL_IN", "all-in" },
{ 0, NULL, NULL }
        };
        if (g_once_init_enter (&gtype_id)) {
            GType new_type = g_enum_register_static (g_intern_static_string ("ArvGvspContentType"), values);
            g_once_init_leave (&gtype_id, new_type);
        }
        return (GType) gtype_id;
        }

GType
arv_gvsp_payload_type_get_type (void)
{
static gsize gtype_id = 0;
static const GEnumValue values[] = {
    { C_ENUM(ARV_GVSP_PAYLOAD_TYPE_IMAGE), "ARV_GVSP_PAYLOAD_TYPE_IMAGE", "image" },
    { C_ENUM(ARV_GVSP_PAYLOAD_TYPE_RAWDATA), "ARV_GVSP_PAYLOAD_TYPE_RAWDATA", "rawdata" },
    { C_ENUM(ARV_GVSP_PAYLOAD_TYPE_FILE), "ARV_GVSP_PAYLOAD_TYPE_FILE", "file" },
    { C_ENUM(ARV_GVSP_PAYLOAD_TYPE_CHUNK_DATA), "ARV_GVSP_PAYLOAD_TYPE_CHUNK_DATA", "chunk-data" },
    { C_ENUM(ARV_GVSP_PAYLOAD_TYPE_EXTENDED_CHUNK_DATA), "ARV_GVSP_PAYLOAD_TYPE_EXTENDED_CHUNK_DATA", "extended-chunk-data" },
    { C_ENUM(ARV_GVSP_PAYLOAD_TYPE_JPEG), "ARV_GVSP_PAYLOAD_TYPE_JPEG", "jpeg" },
    { C_ENUM(ARV_GVSP_PAYLOAD_TYPE_JPEG2000), "ARV_GVSP_PAYLOAD_TYPE_JPEG2000", "jpeg2000" },
    { C_ENUM(ARV_GVSP_PAYLOAD_TYPE_H264), "ARV_GVSP_PAYLOAD_TYPE_H264", "h264" },
    { C_ENUM(ARV_GVSP_PAYLOAD_TYPE_MULTIZONE_IMAGE), "ARV_GVSP_PAYLOAD_TYPE_MULTIZONE_IMAGE", "multizone-image" },
    { C_ENUM(ARV_GVSP_PAYLOAD_TYPE_IMAGE_EXTENDED_CHUNK), "ARV_GVSP_PAYLOAD_TYPE_IMAGE_EXTENDED_CHUNK", "image-extended-chunk" },
{ 0, NULL, NULL }
        };
        if (g_once_init_enter (&gtype_id)) {
            GType new_type = g_enum_register_static (g_intern_static_string ("ArvGvspPayloadType"), values);
            g_once_init_leave (&gtype_id, new_type);
        }
        return (GType) gtype_id;
        }

/* enumerations from "arvuvcpprivate.h" */

GType
arv_uvcp_status_get_type (void)
{
static gsize gtype_id = 0;
static const GEnumValue values[] = {
    { C_ENUM(ARV_UVCP_STATUS_SUCCESS), "ARV_UVCP_STATUS_SUCCESS", "success" },
    { C_ENUM(ARV_UVCP_STATUS_NOT_IMPLEMENTED), "ARV_UVCP_STATUS_NOT_IMPLEMENTED", "not-implemented" },
    { C_ENUM(ARV_UVCP_STATUS_INVALID_PARAMETER), "ARV_UVCP_STATUS_INVALID_PARAMETER", "invalid-parameter" },
    { C_ENUM(ARV_UVCP_STATUS_INVALID_ADDRESS), "ARV_UVCP_STATUS_INVALID_ADDRESS", "invalid-address" },
    { C_ENUM(ARV_UVCP_STATUS_WRITE_PROTECT), "ARV_UVCP_STATUS_WRITE_PROTECT", "write-protect" },
    { C_ENUM(ARV_UVCP_STATUS_BAD_ALIGNMENT), "ARV_UVCP_STATUS_BAD_ALIGNMENT", "bad-alignment" },
    { C_ENUM(ARV_UVCP_STATUS_ACCESS_DENIED), "ARV_UVCP_STATUS_ACCESS_DENIED", "access-denied" },
    { C_ENUM(ARV_UVCP_STATUS_BUSY), "ARV_UVCP_STATUS_BUSY", "busy" },
    { C_ENUM(ARV_UVCP_STATUS_MSG_TIMEOUT), "ARV_UVCP_STATUS_MSG_TIMEOUT", "msg-timeout" },
    { C_ENUM(ARV_UVCP_STATUS_INVALID_HEADER), "ARV_UVCP_STATUS_INVALID_HEADER", "invalid-header" },
    { C_ENUM(ARV_UVCP_STATUS_WRONG_CONFIG), "ARV_UVCP_STATUS_WRONG_CONFIG", "wrong-config" },
    { C_ENUM(ARV_UVCP_STATUS_ERROR), "ARV_UVCP_STATUS_ERROR", "error" },
    { C_ENUM(ARV_UVCP_STATUS_RESEND_NOT_SUPPORTED), "ARV_UVCP_STATUS_RESEND_NOT_SUPPORTED", "resend-not-supported" },
    { C_ENUM(ARV_UVCP_STATUS_DSI_ENDPOINT_HALTED), "ARV_UVCP_STATUS_DSI_ENDPOINT_HALTED", "dsi-endpoint-halted" },
    { C_ENUM(ARV_UVCP_STATUS_SI_PAYLOAD_SIZE_NOT_ALIGNED), "ARV_UVCP_STATUS_SI_PAYLOAD_SIZE_NOT_ALIGNED", "si-payload-size-not-aligned" },
    { C_ENUM(ARV_UVCP_STATUS_SI_REGISTERS_INCONSISTENT), "ARV_UVCP_STATUS_SI_REGISTERS_INCONSISTENT", "si-registers-inconsistent" },
    { C_ENUM(ARV_UVCP_STATUS_DATA_DISCARDED), "ARV_UVCP_STATUS_DATA_DISCARDED", "data-discarded" },
    { C_ENUM(ARV_UVCP_STATUS_DATA_OVERRUN), "ARV_UVCP_STATUS_DATA_OVERRUN", "data-overrun" },
{ 0, NULL, NULL }
        };
        if (g_once_init_enter (&gtype_id)) {
            GType new_type = g_enum_register_static (g_intern_static_string ("ArvUvcpStatus"), values);
            g_once_init_leave (&gtype_id, new_type);
        }
        return (GType) gtype_id;
        }

GType
arv_uvcp_flags_get_type (void)
{
static gsize gtype_id = 0;
static const GFlagsValue values[] = {
    { C_FLAGS(ARV_UVCP_FLAGS_REQUEST_ACK), "ARV_UVCP_FLAGS_REQUEST_ACK", "request-ack" },
    { C_FLAGS(ARV_UVCP_FLAGS_COMMAND_RESEND), "ARV_UVCP_FLAGS_COMMAND_RESEND", "command-resend" },
{ 0, NULL, NULL }
        };
        if (g_once_init_enter (&gtype_id)) {
            GType new_type = g_flags_register_static (g_intern_static_string ("ArvUvcpFlags"), values);
            g_once_init_leave (&gtype_id, new_type);
        }
        return (GType) gtype_id;
        }

GType
arv_uvcp_command_get_type (void)
{
static gsize gtype_id = 0;
static const GEnumValue values[] = {
    { C_ENUM(ARV_UVCP_COMMAND_READ_MEMORY_CMD), "ARV_UVCP_COMMAND_READ_MEMORY_CMD", "read-memory-cmd" },
    { C_ENUM(ARV_UVCP_COMMAND_READ_MEMORY_ACK), "ARV_UVCP_COMMAND_READ_MEMORY_ACK", "read-memory-ack" },
    { C_ENUM(ARV_UVCP_COMMAND_WRITE_MEMORY_CMD), "ARV_UVCP_COMMAND_WRITE_MEMORY_CMD", "write-memory-cmd" },
    { C_ENUM(ARV_UVCP_COMMAND_WRITE_MEMORY_ACK), "ARV_UVCP_COMMAND_WRITE_MEMORY_ACK", "write-memory-ack" },
    { C_ENUM(ARV_UVCP_COMMAND_PENDING_ACK), "ARV_UVCP_COMMAND_PENDING_ACK", "pending-ack" },
    { C_ENUM(ARV_UVCP_COMMAND_EVENT_CMD), "ARV_UVCP_COMMAND_EVENT_CMD", "event-cmd" },
    { C_ENUM(ARV_UVCP_COMMAND_EVENT_ACK), "ARV_UVCP_COMMAND_EVENT_ACK", "event-ack" },
{ 0, NULL, NULL }
        };
        if (g_once_init_enter (&gtype_id)) {
            GType new_type = g_enum_register_static (g_intern_static_string ("ArvUvcpCommand"), values);
            g_once_init_leave (&gtype_id, new_type);
        }
        return (GType) gtype_id;
        }

GType
arv_uvcp_manifest_schema_type_get_type (void)
{
static gsize gtype_id = 0;
static const GEnumValue values[] = {
    { C_ENUM(ARV_UVCP_SCHEMA_RAW), "ARV_UVCP_SCHEMA_RAW", "raw" },
    { C_ENUM(ARV_UVCP_SCHEMA_ZIP), "ARV_UVCP_SCHEMA_ZIP", "zip" },
{ 0, NULL, NULL }
        };
        if (g_once_init_enter (&gtype_id)) {
            GType new_type = g_enum_register_static (g_intern_static_string ("ArvUvcpManifestSchemaType"), values);
            g_once_init_leave (&gtype_id, new_type);
        }
        return (GType) gtype_id;
        }

/* enumerations from "arvuvdeviceprivate.h" */

GType
arv_uv_endpoint_type_get_type (void)
{
static gsize gtype_id = 0;
static const GEnumValue values[] = {
    { C_ENUM(ARV_UV_ENDPOINT_CONTROL), "ARV_UV_ENDPOINT_CONTROL", "control" },
    { C_ENUM(ARV_UV_ENDPOINT_DATA), "ARV_UV_ENDPOINT_DATA", "data" },
{ 0, NULL, NULL }
        };
        if (g_once_init_enter (&gtype_id)) {
            GType new_type = g_enum_register_static (g_intern_static_string ("ArvUvEndpointType"), values);
            g_once_init_leave (&gtype_id, new_type);
        }
        return (GType) gtype_id;
        }

/* enumerations from "arvuvspprivate.h" */

GType
arv_uvsp_packet_type_get_type (void)
{
static gsize gtype_id = 0;
static const GEnumValue values[] = {
    { C_ENUM(ARV_UVSP_PACKET_TYPE_UNKNOWN), "ARV_UVSP_PACKET_TYPE_UNKNOWN", "unknown" },
    { C_ENUM(ARV_UVSP_PACKET_TYPE_LEADER), "ARV_UVSP_PACKET_TYPE_LEADER", "leader" },
    { C_ENUM(ARV_UVSP_PACKET_TYPE_TRAILER), "ARV_UVSP_PACKET_TYPE_TRAILER", "trailer" },
    { C_ENUM(ARV_UVSP_PACKET_TYPE_DATA), "ARV_UVSP_PACKET_TYPE_DATA", "data" },
{ 0, NULL, NULL }
        };
        if (g_once_init_enter (&gtype_id)) {
            GType new_type = g_enum_register_static (g_intern_static_string ("ArvUvspPacketType"), values);
            g_once_init_leave (&gtype_id, new_type);
        }
        return (GType) gtype_id;
        }

GType
arv_uvsp_payload_type_get_type (void)
{
static gsize gtype_id = 0;
static const GEnumValue values[] = {
    { C_ENUM(ARV_UVSP_PAYLOAD_TYPE_UNKNOWN), "ARV_UVSP_PAYLOAD_TYPE_UNKNOWN", "unknown" },
    { C_ENUM(ARV_UVSP_PAYLOAD_TYPE_IMAGE), "ARV_UVSP_PAYLOAD_TYPE_IMAGE", "image" },
    { C_ENUM(ARV_UVSP_PAYLOAD_TYPE_CHUNK), "ARV_UVSP_PAYLOAD_TYPE_CHUNK", "chunk" },
    { C_ENUM(ARV_UVSP_PAYLOAD_TYPE_EXTENDED_CHUNK), "ARV_UVSP_PAYLOAD_TYPE_EXTENDED_CHUNK", "extended-chunk" },
{ 0, NULL, NULL }
        };
        if (g_once_init_enter (&gtype_id)) {
            GType new_type = g_enum_register_static (g_intern_static_string ("ArvUvspPayloadType"), values);
            g_once_init_leave (&gtype_id, new_type);
        }
        return (GType) gtype_id;
        }

/* Generated data ends here */

