
/* This file is generated by glib-mkenums, do not modify it. This code is licensed under the same license as the containing project. Note that it links to GLib, so must comply with the LGPL linking clauses. */

#include "arvenumtypes.h"
#include "arv.h"
#include "arvtypes.h"
#include "arvbuffer.h"
#include "arvcamera.h"
#include "arvchunkparser.h"
#include "arvdebug.h"
#include "arvdevice.h"
#include "arvdomcharacterdata.h"
#include "arvdomdocumentfragment.h"
#include "arvdomdocument.h"
#include "arvdomelement.h"
#include "arvdomimplementation.h"
#include "arvdomnamednodemap.h"
#include "arvdomnode.h"
#include "arvdomnodechildlist.h"
#include "arvdomnodelist.h"
#include "arvdomparser.h"
#include "arvdomtext.h"
#include "arvenums.h"
#include "arvevaluator.h"
#include "arvfakecamera.h"
#include "arvfakedevice.h"
#include "arvfakeinterface.h"
#include "arvfakestream.h"
#include "arvgcboolean.h"
#include "arvgccategory.h"
#include "arvgccommand.h"
#include "arvgcconverter.h"
#include "arvgcconverternode.h"
#include "arvgcenumentry.h"
#include "arvgcenumeration.h"
#include "arvgcenums.h"
#include "arvgcfeaturenode.h"
#include "arvgcfloat.h"
#include "arvgcfloatnode.h"
#include "arvgcgroupnode.h"
#include "arvgc.h"
#include "arvgcindexnode.h"
#include "arvgcintconverternode.h"
#include "arvgcinteger.h"
#include "arvgcintegernode.h"
#include "arvgcinvalidatornode.h"
#include "arvgcnode.h"
#include "arvgcport.h"
#include "arvgcpropertynode.h"
#include "arvgcregisterdescriptionnode.h"
#include "arvgcregister.h"
#include "arvgcregisternode.h"
#include "arvgcintregnode.h"
#include "arvgcstringnode.h"
#include "arvgcmaskedintregnode.h"
#include "arvgcfloatregnode.h"
#include "arvgcstringregnode.h"
#include "arvgcstructregnode.h"
#include "arvgcstring.h"
#include "arvgcselector.h"
#include "arvgcstructentrynode.h"
#include "arvgcswissknife.h"
#include "arvgcswissknifenode.h"
#include "arvgcintswissknifenode.h"
#include "arvgcvalueindexednode.h"
#include "arvgvdevice.h"
#include "arvgvfakecamera.h"
#include "arvgvinterface.h"
#include "arvgvstream.h"
#include "arvinterface.h"
#include "arvsystem.h"
#include "arvrealtime.h"
#include "arvstream.h"
#include "arvxmlschema.h"
#include "arvuvinterface.h"
#include "arvuvdevice.h"
#include "arvuvstream.h"
#include "arvmisc.h"
#include "arvzip.h"
#include "arvstr.h"

#define C_ENUM(v) ((gint) v)
#define C_FLAGS(v) ((guint) v)

/* enumerations from "arvbuffer.h" */

GType
arv_buffer_status_get_type (void)
{
static gsize gtype_id = 0;
static const GEnumValue values[] = {
    { C_ENUM(ARV_BUFFER_STATUS_UNKNOWN), "ARV_BUFFER_STATUS_UNKNOWN", "unknown" },
    { C_ENUM(ARV_BUFFER_STATUS_SUCCESS), "ARV_BUFFER_STATUS_SUCCESS", "success" },
    { C_ENUM(ARV_BUFFER_STATUS_CLEARED), "ARV_BUFFER_STATUS_CLEARED", "cleared" },
    { C_ENUM(ARV_BUFFER_STATUS_TIMEOUT), "ARV_BUFFER_STATUS_TIMEOUT", "timeout" },
    { C_ENUM(ARV_BUFFER_STATUS_MISSING_PACKETS), "ARV_BUFFER_STATUS_MISSING_PACKETS", "missing-packets" },
    { C_ENUM(ARV_BUFFER_STATUS_WRONG_PACKET_ID), "ARV_BUFFER_STATUS_WRONG_PACKET_ID", "wrong-packet-id" },
    { C_ENUM(ARV_BUFFER_STATUS_SIZE_MISMATCH), "ARV_BUFFER_STATUS_SIZE_MISMATCH", "size-mismatch" },
    { C_ENUM(ARV_BUFFER_STATUS_FILLING), "ARV_BUFFER_STATUS_FILLING", "filling" },
    { C_ENUM(ARV_BUFFER_STATUS_ABORTED), "ARV_BUFFER_STATUS_ABORTED", "aborted" },
{ 0, NULL, NULL }
        };
        if (g_once_init_enter (&gtype_id)) {
            GType new_type = g_enum_register_static (g_intern_static_string ("ArvBufferStatus"), values);
            g_once_init_leave (&gtype_id, new_type);
        }
        return (GType) gtype_id;
        }

GType
arv_buffer_payload_type_get_type (void)
{
static gsize gtype_id = 0;
static const GEnumValue values[] = {
    { C_ENUM(ARV_BUFFER_PAYLOAD_TYPE_UNKNOWN), "ARV_BUFFER_PAYLOAD_TYPE_UNKNOWN", "unknown" },
    { C_ENUM(ARV_BUFFER_PAYLOAD_TYPE_IMAGE), "ARV_BUFFER_PAYLOAD_TYPE_IMAGE", "image" },
    { C_ENUM(ARV_BUFFER_PAYLOAD_TYPE_RAWDATA), "ARV_BUFFER_PAYLOAD_TYPE_RAWDATA", "rawdata" },
    { C_ENUM(ARV_BUFFER_PAYLOAD_TYPE_FILE), "ARV_BUFFER_PAYLOAD_TYPE_FILE", "file" },
    { C_ENUM(ARV_BUFFER_PAYLOAD_TYPE_CHUNK_DATA), "ARV_BUFFER_PAYLOAD_TYPE_CHUNK_DATA", "chunk-data" },
    { C_ENUM(ARV_BUFFER_PAYLOAD_TYPE_EXTENDED_CHUNK_DATA), "ARV_BUFFER_PAYLOAD_TYPE_EXTENDED_CHUNK_DATA", "extended-chunk-data" },
    { C_ENUM(ARV_BUFFER_PAYLOAD_TYPE_JPEG), "ARV_BUFFER_PAYLOAD_TYPE_JPEG", "jpeg" },
    { C_ENUM(ARV_BUFFER_PAYLOAD_TYPE_JPEG2000), "ARV_BUFFER_PAYLOAD_TYPE_JPEG2000", "jpeg2000" },
    { C_ENUM(ARV_BUFFER_PAYLOAD_TYPE_H264), "ARV_BUFFER_PAYLOAD_TYPE_H264", "h264" },
    { C_ENUM(ARV_BUFFER_PAYLOAD_TYPE_MULTIZONE_IMAGE), "ARV_BUFFER_PAYLOAD_TYPE_MULTIZONE_IMAGE", "multizone-image" },
    { C_ENUM(ARV_BUFFER_PAYLOAD_TYPE_IMAGE_EXTENDED_CHUNK), "ARV_BUFFER_PAYLOAD_TYPE_IMAGE_EXTENDED_CHUNK", "image-extended-chunk" },
{ 0, NULL, NULL }
        };
        if (g_once_init_enter (&gtype_id)) {
            GType new_type = g_enum_register_static (g_intern_static_string ("ArvBufferPayloadType"), values);
            g_once_init_leave (&gtype_id, new_type);
        }
        return (GType) gtype_id;
        }

/* enumerations from "arvchunkparser.h" */

GType
arv_chunk_parser_error_get_type (void)
{
static gsize gtype_id = 0;
static const GEnumValue values[] = {
    { C_ENUM(ARV_CHUNK_PARSER_ERROR_INVALID_FEATURE_TYPE), "ARV_CHUNK_PARSER_ERROR_INVALID_FEATURE_TYPE", "invalid-feature-type" },
    { C_ENUM(ARV_CHUNK_PARSER_ERROR_BUFFER_NOT_FOUND), "ARV_CHUNK_PARSER_ERROR_BUFFER_NOT_FOUND", "buffer-not-found" },
    { C_ENUM(ARV_CHUNK_PARSER_ERROR_CHUNK_NOT_FOUND), "ARV_CHUNK_PARSER_ERROR_CHUNK_NOT_FOUND", "chunk-not-found" },
{ 0, NULL, NULL }
        };
        if (g_once_init_enter (&gtype_id)) {
            GType new_type = g_enum_register_static (g_intern_static_string ("ArvChunkParserError"), values);
            g_once_init_leave (&gtype_id, new_type);
        }
        return (GType) gtype_id;
        }

/* enumerations from "arvdevice.h" */

GType
arv_device_error_get_type (void)
{
static gsize gtype_id = 0;
static const GEnumValue values[] = {
    { C_ENUM(ARV_DEVICE_ERROR_WRONG_FEATURE), "ARV_DEVICE_ERROR_WRONG_FEATURE", "wrong-feature" },
    { C_ENUM(ARV_DEVICE_ERROR_FEATURE_NOT_FOUND), "ARV_DEVICE_ERROR_FEATURE_NOT_FOUND", "feature-not-found" },
    { C_ENUM(ARV_DEVICE_ERROR_NOT_CONNECTED), "ARV_DEVICE_ERROR_NOT_CONNECTED", "not-connected" },
    { C_ENUM(ARV_DEVICE_ERROR_PROTOCOL_ERROR), "ARV_DEVICE_ERROR_PROTOCOL_ERROR", "protocol-error" },
    { C_ENUM(ARV_DEVICE_ERROR_TRANSFER_ERROR), "ARV_DEVICE_ERROR_TRANSFER_ERROR", "transfer-error" },
    { C_ENUM(ARV_DEVICE_ERROR_TIMEOUT), "ARV_DEVICE_ERROR_TIMEOUT", "timeout" },
    { C_ENUM(ARV_DEVICE_ERROR_NOT_FOUND), "ARV_DEVICE_ERROR_NOT_FOUND", "not-found" },
    { C_ENUM(ARV_DEVICE_ERROR_INVALID_PARAMETER), "ARV_DEVICE_ERROR_INVALID_PARAMETER", "invalid-parameter" },
    { C_ENUM(ARV_DEVICE_ERROR_GENICAM_NOT_FOUND), "ARV_DEVICE_ERROR_GENICAM_NOT_FOUND", "genicam-not-found" },
    { C_ENUM(ARV_DEVICE_ERROR_NO_STREAM_CHANNEL), "ARV_DEVICE_ERROR_NO_STREAM_CHANNEL", "no-stream-channel" },
    { C_ENUM(ARV_DEVICE_ERROR_NOT_CONTROLLER), "ARV_DEVICE_ERROR_NOT_CONTROLLER", "not-controller" },
    { C_ENUM(ARV_DEVICE_ERROR_UNKNOWN), "ARV_DEVICE_ERROR_UNKNOWN", "unknown" },
{ 0, NULL, NULL }
        };
        if (g_once_init_enter (&gtype_id)) {
            GType new_type = g_enum_register_static (g_intern_static_string ("ArvDeviceError"), values);
            g_once_init_leave (&gtype_id, new_type);
        }
        return (GType) gtype_id;
        }

/* enumerations from "arvdomnode.h" */

GType
arv_dom_node_type_get_type (void)
{
static gsize gtype_id = 0;
static const GEnumValue values[] = {
    { C_ENUM(ARV_DOM_NODE_TYPE_ELEMENT_NODE), "ARV_DOM_NODE_TYPE_ELEMENT_NODE", "element-node" },
    { C_ENUM(ARV_DOM_NODE_TYPE_ATTRIBUTE_NODE), "ARV_DOM_NODE_TYPE_ATTRIBUTE_NODE", "attribute-node" },
    { C_ENUM(ARV_DOM_NODE_TYPE_TEXT_NODE), "ARV_DOM_NODE_TYPE_TEXT_NODE", "text-node" },
    { C_ENUM(ARV_DOM_NODE_TYPE_CDATA_SECTION_NODE), "ARV_DOM_NODE_TYPE_CDATA_SECTION_NODE", "cdata-section-node" },
    { C_ENUM(ARV_DOM_NODE_TYPE_ENTITY_REFERENCE_NODE), "ARV_DOM_NODE_TYPE_ENTITY_REFERENCE_NODE", "entity-reference-node" },
    { C_ENUM(ARV_DOM_NODE_TYPE_ENTITY_NODE), "ARV_DOM_NODE_TYPE_ENTITY_NODE", "entity-node" },
    { C_ENUM(ARV_DOM_NODE_TYPE_PROCESSING_INSTRUCTION_NODE), "ARV_DOM_NODE_TYPE_PROCESSING_INSTRUCTION_NODE", "processing-instruction-node" },
    { C_ENUM(ARV_DOM_NODE_TYPE_COMMENT_NODE), "ARV_DOM_NODE_TYPE_COMMENT_NODE", "comment-node" },
    { C_ENUM(ARV_DOM_NODE_TYPE_DOCUMENT_NODE), "ARV_DOM_NODE_TYPE_DOCUMENT_NODE", "document-node" },
    { C_ENUM(ARV_DOM_NODE_TYPE_DOCUMENT_TYPE_NODE), "ARV_DOM_NODE_TYPE_DOCUMENT_TYPE_NODE", "document-type-node" },
    { C_ENUM(ARV_DOM_NODE_TYPE_DOCUMENT_FRAGMENT_NODE), "ARV_DOM_NODE_TYPE_DOCUMENT_FRAGMENT_NODE", "document-fragment-node" },
    { C_ENUM(ARV_DOM_NODE_TYPE_NOTATION_NODE), "ARV_DOM_NODE_TYPE_NOTATION_NODE", "notation-node" },
{ 0, NULL, NULL }
        };
        if (g_once_init_enter (&gtype_id)) {
            GType new_type = g_enum_register_static (g_intern_static_string ("ArvDomNodeType"), values);
            g_once_init_leave (&gtype_id, new_type);
        }
        return (GType) gtype_id;
        }

/* enumerations from "arvenums.h" */

GType
arv_auto_get_type (void)
{
static gsize gtype_id = 0;
static const GEnumValue values[] = {
    { C_ENUM(ARV_AUTO_OFF), "ARV_AUTO_OFF", "off" },
    { C_ENUM(ARV_AUTO_ONCE), "ARV_AUTO_ONCE", "once" },
    { C_ENUM(ARV_AUTO_CONTINUOUS), "ARV_AUTO_CONTINUOUS", "continuous" },
{ 0, NULL, NULL }
        };
        if (g_once_init_enter (&gtype_id)) {
            GType new_type = g_enum_register_static (g_intern_static_string ("ArvAuto"), values);
            g_once_init_leave (&gtype_id, new_type);
        }
        return (GType) gtype_id;
        }

GType
arv_acquisition_mode_get_type (void)
{
static gsize gtype_id = 0;
static const GEnumValue values[] = {
    { C_ENUM(ARV_ACQUISITION_MODE_CONTINUOUS), "ARV_ACQUISITION_MODE_CONTINUOUS", "continuous" },
    { C_ENUM(ARV_ACQUISITION_MODE_SINGLE_FRAME), "ARV_ACQUISITION_MODE_SINGLE_FRAME", "single-frame" },
    { C_ENUM(ARV_ACQUISITION_MODE_MULTI_FRAME), "ARV_ACQUISITION_MODE_MULTI_FRAME", "multi-frame" },
{ 0, NULL, NULL }
        };
        if (g_once_init_enter (&gtype_id)) {
            GType new_type = g_enum_register_static (g_intern_static_string ("ArvAcquisitionMode"), values);
            g_once_init_leave (&gtype_id, new_type);
        }
        return (GType) gtype_id;
        }

GType
arv_exposure_mode_get_type (void)
{
static gsize gtype_id = 0;
static const GEnumValue values[] = {
    { C_ENUM(ARV_EXPOSURE_MODE_OFF), "ARV_EXPOSURE_MODE_OFF", "off" },
    { C_ENUM(ARV_EXPOSURE_MODE_TIMED), "ARV_EXPOSURE_MODE_TIMED", "timed" },
    { C_ENUM(ARV_EXPOSURE_MODE_TRIGGER_WIDTH), "ARV_EXPOSURE_MODE_TRIGGER_WIDTH", "trigger-width" },
    { C_ENUM(ARV_EXPOSURE_MODE_TRIGGER_CONTROLLED), "ARV_EXPOSURE_MODE_TRIGGER_CONTROLLED", "trigger-controlled" },
{ 0, NULL, NULL }
        };
        if (g_once_init_enter (&gtype_id)) {
            GType new_type = g_enum_register_static (g_intern_static_string ("ArvExposureMode"), values);
            g_once_init_leave (&gtype_id, new_type);
        }
        return (GType) gtype_id;
        }

GType
arv_uv_usb_mode_get_type (void)
{
static gsize gtype_id = 0;
static const GEnumValue values[] = {
    { C_ENUM(ARV_UV_USB_MODE_SYNC), "ARV_UV_USB_MODE_SYNC", "sync" },
    { C_ENUM(ARV_UV_USB_MODE_ASYNC), "ARV_UV_USB_MODE_ASYNC", "async" },
    { C_ENUM(ARV_UV_USB_MODE_DEFAULT), "ARV_UV_USB_MODE_DEFAULT", "default" },
{ 0, NULL, NULL }
        };
        if (g_once_init_enter (&gtype_id)) {
            GType new_type = g_enum_register_static (g_intern_static_string ("ArvUvUsbMode"), values);
            g_once_init_leave (&gtype_id, new_type);
        }
        return (GType) gtype_id;
        }

/* enumerations from "arvgc.h" */

GType
arv_gc_error_get_type (void)
{
static gsize gtype_id = 0;
static const GEnumValue values[] = {
    { C_ENUM(ARV_GC_ERROR_PROPERTY_NOT_DEFINED), "ARV_GC_ERROR_PROPERTY_NOT_DEFINED", "property-not-defined" },
    { C_ENUM(ARV_GC_ERROR_PVALUE_NOT_DEFINED), "ARV_GC_ERROR_PVALUE_NOT_DEFINED", "pvalue-not-defined" },
    { C_ENUM(ARV_GC_ERROR_INVALID_PVALUE), "ARV_GC_ERROR_INVALID_PVALUE", "invalid-pvalue" },
    { C_ENUM(ARV_GC_ERROR_EMPTY_ENUMERATION), "ARV_GC_ERROR_EMPTY_ENUMERATION", "empty-enumeration" },
    { C_ENUM(ARV_GC_ERROR_OUT_OF_RANGE), "ARV_GC_ERROR_OUT_OF_RANGE", "out-of-range" },
    { C_ENUM(ARV_GC_ERROR_NO_DEVICE_SET), "ARV_GC_ERROR_NO_DEVICE_SET", "no-device-set" },
    { C_ENUM(ARV_GC_ERROR_NO_EVENT_IMPLEMENTATION), "ARV_GC_ERROR_NO_EVENT_IMPLEMENTATION", "no-event-implementation" },
    { C_ENUM(ARV_GC_ERROR_NODE_NOT_FOUND), "ARV_GC_ERROR_NODE_NOT_FOUND", "node-not-found" },
    { C_ENUM(ARV_GC_ERROR_ENUM_ENTRY_NOT_FOUND), "ARV_GC_ERROR_ENUM_ENTRY_NOT_FOUND", "enum-entry-not-found" },
    { C_ENUM(ARV_GC_ERROR_INVALID_LENGTH), "ARV_GC_ERROR_INVALID_LENGTH", "invalid-length" },
    { C_ENUM(ARV_GC_ERROR_READ_ONLY), "ARV_GC_ERROR_READ_ONLY", "read-only" },
    { C_ENUM(ARV_GC_ERROR_SET_FROM_STRING_UNDEFINED), "ARV_GC_ERROR_SET_FROM_STRING_UNDEFINED", "set-from-string-undefined" },
    { C_ENUM(ARV_GC_ERROR_GET_AS_STRING_UNDEFINED), "ARV_GC_ERROR_GET_AS_STRING_UNDEFINED", "get-as-string-undefined" },
    { C_ENUM(ARV_GC_ERROR_INVALID_BIT_RANGE), "ARV_GC_ERROR_INVALID_BIT_RANGE", "invalid-bit-range" },
{ 0, NULL, NULL }
        };
        if (g_once_init_enter (&gtype_id)) {
            GType new_type = g_enum_register_static (g_intern_static_string ("ArvGcError"), values);
            g_once_init_leave (&gtype_id, new_type);
        }
        return (GType) gtype_id;
        }

GType
arv_register_cache_policy_get_type (void)
{
static gsize gtype_id = 0;
static const GEnumValue values[] = {
    { C_ENUM(ARV_REGISTER_CACHE_POLICY_DISABLE), "ARV_REGISTER_CACHE_POLICY_DISABLE", "disable" },
    { C_ENUM(ARV_REGISTER_CACHE_POLICY_ENABLE), "ARV_REGISTER_CACHE_POLICY_ENABLE", "enable" },
    { C_ENUM(ARV_REGISTER_CACHE_POLICY_DEBUG), "ARV_REGISTER_CACHE_POLICY_DEBUG", "debug" },
    { C_ENUM(ARV_REGISTER_CACHE_POLICY_DEFAULT), "ARV_REGISTER_CACHE_POLICY_DEFAULT", "default" },
{ 0, NULL, NULL }
        };
        if (g_once_init_enter (&gtype_id)) {
            GType new_type = g_enum_register_static (g_intern_static_string ("ArvRegisterCachePolicy"), values);
            g_once_init_leave (&gtype_id, new_type);
        }
        return (GType) gtype_id;
        }

GType
arv_range_check_policy_get_type (void)
{
static gsize gtype_id = 0;
static const GEnumValue values[] = {
    { C_ENUM(ARV_RANGE_CHECK_POLICY_DISABLE), "ARV_RANGE_CHECK_POLICY_DISABLE", "disable" },
    { C_ENUM(ARV_RANGE_CHECK_POLICY_ENABLE), "ARV_RANGE_CHECK_POLICY_ENABLE", "enable" },
    { C_ENUM(ARV_RANGE_CHECK_POLICY_DEBUG), "ARV_RANGE_CHECK_POLICY_DEBUG", "debug" },
    { C_ENUM(ARV_RANGE_CHECK_POLICY_DEFAULT), "ARV_RANGE_CHECK_POLICY_DEFAULT", "default" },
{ 0, NULL, NULL }
        };
        if (g_once_init_enter (&gtype_id)) {
            GType new_type = g_enum_register_static (g_intern_static_string ("ArvRangeCheckPolicy"), values);
            g_once_init_leave (&gtype_id, new_type);
        }
        return (GType) gtype_id;
        }

GType
arv_access_check_policy_get_type (void)
{
static gsize gtype_id = 0;
static const GEnumValue values[] = {
    { C_ENUM(ARV_ACCESS_CHECK_POLICY_DISABLE), "ARV_ACCESS_CHECK_POLICY_DISABLE", "disable" },
    { C_ENUM(ARV_ACCESS_CHECK_POLICY_ENABLE), "ARV_ACCESS_CHECK_POLICY_ENABLE", "enable" },
    { C_ENUM(ARV_ACCESS_CHECK_POLICY_DEFAULT), "ARV_ACCESS_CHECK_POLICY_DEFAULT", "default" },
{ 0, NULL, NULL }
        };
        if (g_once_init_enter (&gtype_id)) {
            GType new_type = g_enum_register_static (g_intern_static_string ("ArvAccessCheckPolicy"), values);
            g_once_init_leave (&gtype_id, new_type);
        }
        return (GType) gtype_id;
        }

/* enumerations from "arvgcenums.h" */

GType
arv_gc_name_space_get_type (void)
{
static gsize gtype_id = 0;
static const GEnumValue values[] = {
    { C_ENUM(ARV_GC_NAME_SPACE_UNDEFINED), "ARV_GC_NAME_SPACE_UNDEFINED", "undefined" },
    { C_ENUM(ARV_GC_NAME_SPACE_STANDARD), "ARV_GC_NAME_SPACE_STANDARD", "standard" },
    { C_ENUM(ARV_GC_NAME_SPACE_CUSTOM), "ARV_GC_NAME_SPACE_CUSTOM", "custom" },
{ 0, NULL, NULL }
        };
        if (g_once_init_enter (&gtype_id)) {
            GType new_type = g_enum_register_static (g_intern_static_string ("ArvGcNameSpace"), values);
            g_once_init_leave (&gtype_id, new_type);
        }
        return (GType) gtype_id;
        }

GType
arv_gc_access_mode_get_type (void)
{
static gsize gtype_id = 0;
static const GEnumValue values[] = {
    { C_ENUM(ARV_GC_ACCESS_MODE_UNDEFINED), "ARV_GC_ACCESS_MODE_UNDEFINED", "undefined" },
    { C_ENUM(ARV_GC_ACCESS_MODE_RO), "ARV_GC_ACCESS_MODE_RO", "ro" },
    { C_ENUM(ARV_GC_ACCESS_MODE_WO), "ARV_GC_ACCESS_MODE_WO", "wo" },
    { C_ENUM(ARV_GC_ACCESS_MODE_RW), "ARV_GC_ACCESS_MODE_RW", "rw" },
{ 0, NULL, NULL }
        };
        if (g_once_init_enter (&gtype_id)) {
            GType new_type = g_enum_register_static (g_intern_static_string ("ArvGcAccessMode"), values);
            g_once_init_leave (&gtype_id, new_type);
        }
        return (GType) gtype_id;
        }

GType
arv_gc_cachable_get_type (void)
{
static gsize gtype_id = 0;
static const GEnumValue values[] = {
    { C_ENUM(ARV_GC_CACHABLE_UNDEFINED), "ARV_GC_CACHABLE_UNDEFINED", "undefined" },
    { C_ENUM(ARV_GC_CACHABLE_NO_CACHE), "ARV_GC_CACHABLE_NO_CACHE", "no-cache" },
    { C_ENUM(ARV_GC_CACHABLE_WRITE_THROUGH), "ARV_GC_CACHABLE_WRITE_THROUGH", "write-through" },
    { C_ENUM(ARV_GC_CACHABLE_WRITE_AROUND), "ARV_GC_CACHABLE_WRITE_AROUND", "write-around" },
{ 0, NULL, NULL }
        };
        if (g_once_init_enter (&gtype_id)) {
            GType new_type = g_enum_register_static (g_intern_static_string ("ArvGcCachable"), values);
            g_once_init_leave (&gtype_id, new_type);
        }
        return (GType) gtype_id;
        }

GType
arv_gc_signedness_get_type (void)
{
static gsize gtype_id = 0;
static const GEnumValue values[] = {
    { C_ENUM(ARV_GC_SIGNEDNESS_UNDEFINED), "ARV_GC_SIGNEDNESS_UNDEFINED", "undefined" },
    { C_ENUM(ARV_GC_SIGNEDNESS_SIGNED), "ARV_GC_SIGNEDNESS_SIGNED", "signed" },
    { C_ENUM(ARV_GC_SIGNEDNESS_UNSIGNED), "ARV_GC_SIGNEDNESS_UNSIGNED", "unsigned" },
{ 0, NULL, NULL }
        };
        if (g_once_init_enter (&gtype_id)) {
            GType new_type = g_enum_register_static (g_intern_static_string ("ArvGcSignedness"), values);
            g_once_init_leave (&gtype_id, new_type);
        }
        return (GType) gtype_id;
        }

GType
arv_gc_is_linear_get_type (void)
{
static gsize gtype_id = 0;
static const GEnumValue values[] = {
    { C_ENUM(ARV_GC_IS_LINEAR_UNDEFINED), "ARV_GC_IS_LINEAR_UNDEFINED", "undefined" },
    { C_ENUM(ARV_GC_IS_LINEAR_NO), "ARV_GC_IS_LINEAR_NO", "no" },
    { C_ENUM(ARV_GC_IS_LINEAR_YES), "ARV_GC_IS_LINEAR_YES", "yes" },
{ 0, NULL, NULL }
        };
        if (g_once_init_enter (&gtype_id)) {
            GType new_type = g_enum_register_static (g_intern_static_string ("ArvGcIsLinear"), values);
            g_once_init_leave (&gtype_id, new_type);
        }
        return (GType) gtype_id;
        }

GType
arv_gc_visibility_get_type (void)
{
static gsize gtype_id = 0;
static const GEnumValue values[] = {
    { C_ENUM(ARV_GC_VISIBILITY_UNDEFINED), "ARV_GC_VISIBILITY_UNDEFINED", "undefined" },
    { C_ENUM(ARV_GC_VISIBILITY_INVISIBLE), "ARV_GC_VISIBILITY_INVISIBLE", "invisible" },
    { C_ENUM(ARV_GC_VISIBILITY_GURU), "ARV_GC_VISIBILITY_GURU", "guru" },
    { C_ENUM(ARV_GC_VISIBILITY_EXPERT), "ARV_GC_VISIBILITY_EXPERT", "expert" },
    { C_ENUM(ARV_GC_VISIBILITY_BEGINNER), "ARV_GC_VISIBILITY_BEGINNER", "beginner" },
{ 0, NULL, NULL }
        };
        if (g_once_init_enter (&gtype_id)) {
            GType new_type = g_enum_register_static (g_intern_static_string ("ArvGcVisibility"), values);
            g_once_init_leave (&gtype_id, new_type);
        }
        return (GType) gtype_id;
        }

GType
arv_gc_representation_get_type (void)
{
static gsize gtype_id = 0;
static const GEnumValue values[] = {
    { C_ENUM(ARV_GC_REPRESENTATION_UNDEFINED), "ARV_GC_REPRESENTATION_UNDEFINED", "undefined" },
    { C_ENUM(ARV_GC_REPRESENTATION_LINEAR), "ARV_GC_REPRESENTATION_LINEAR", "linear" },
    { C_ENUM(ARV_GC_REPRESENTATION_LOGARITHMIC), "ARV_GC_REPRESENTATION_LOGARITHMIC", "logarithmic" },
    { C_ENUM(ARV_GC_REPRESENTATION_BOOLEAN), "ARV_GC_REPRESENTATION_BOOLEAN", "boolean" },
    { C_ENUM(ARV_GC_REPRESENTATION_PURE_NUMBER), "ARV_GC_REPRESENTATION_PURE_NUMBER", "pure-number" },
    { C_ENUM(ARV_GC_REPRESENTATION_HEX_NUMBER), "ARV_GC_REPRESENTATION_HEX_NUMBER", "hex-number" },
    { C_ENUM(ARV_GC_REPRESENTATION_IPV4_ADDRESS), "ARV_GC_REPRESENTATION_IPV4_ADDRESS", "ipv4-address" },
    { C_ENUM(ARV_GC_REPRESENTATION_MAC_ADDRESS), "ARV_GC_REPRESENTATION_MAC_ADDRESS", "mac-address" },
{ 0, NULL, NULL }
        };
        if (g_once_init_enter (&gtype_id)) {
            GType new_type = g_enum_register_static (g_intern_static_string ("ArvGcRepresentation"), values);
            g_once_init_leave (&gtype_id, new_type);
        }
        return (GType) gtype_id;
        }

GType
arv_gc_display_notation_get_type (void)
{
static gsize gtype_id = 0;
static const GEnumValue values[] = {
    { C_ENUM(ARV_GC_DISPLAY_NOTATION_UNDEFINED), "ARV_GC_DISPLAY_NOTATION_UNDEFINED", "undefined" },
    { C_ENUM(ARV_GC_DISPLAY_NOTATION_AUTOMATIC), "ARV_GC_DISPLAY_NOTATION_AUTOMATIC", "automatic" },
    { C_ENUM(ARV_GC_DISPLAY_NOTATION_FIXED), "ARV_GC_DISPLAY_NOTATION_FIXED", "fixed" },
    { C_ENUM(ARV_GC_DISPLAY_NOTATION_SCIENTIFIC), "ARV_GC_DISPLAY_NOTATION_SCIENTIFIC", "scientific" },
{ 0, NULL, NULL }
        };
        if (g_once_init_enter (&gtype_id)) {
            GType new_type = g_enum_register_static (g_intern_static_string ("ArvGcDisplayNotation"), values);
            g_once_init_leave (&gtype_id, new_type);
        }
        return (GType) gtype_id;
        }

GType
arv_gc_streamable_get_type (void)
{
static gsize gtype_id = 0;
static const GEnumValue values[] = {
    { C_ENUM(ARV_GC_STREAMABLE_UNDEFINED), "ARV_GC_STREAMABLE_UNDEFINED", "undefined" },
    { C_ENUM(ARV_GC_STREAMABLE_NO), "ARV_GC_STREAMABLE_NO", "no" },
    { C_ENUM(ARV_GC_STREAMABLE_YES), "ARV_GC_STREAMABLE_YES", "yes" },
{ 0, NULL, NULL }
        };
        if (g_once_init_enter (&gtype_id)) {
            GType new_type = g_enum_register_static (g_intern_static_string ("ArvGcStreamable"), values);
            g_once_init_leave (&gtype_id, new_type);
        }
        return (GType) gtype_id;
        }

/* enumerations from "arvgcpropertynode.h" */

GType
arv_gc_property_node_type_get_type (void)
{
static gsize gtype_id = 0;
static const GEnumValue values[] = {
    { C_ENUM(ARV_GC_PROPERTY_NODE_TYPE_UNKNOWN), "ARV_GC_PROPERTY_NODE_TYPE_UNKNOWN", "unknown" },
    { C_ENUM(ARV_GC_PROPERTY_NODE_TYPE_VALUE), "ARV_GC_PROPERTY_NODE_TYPE_VALUE", "value" },
    { C_ENUM(ARV_GC_PROPERTY_NODE_TYPE_ADDRESS), "ARV_GC_PROPERTY_NODE_TYPE_ADDRESS", "address" },
    { C_ENUM(ARV_GC_PROPERTY_NODE_TYPE_DESCRIPTION), "ARV_GC_PROPERTY_NODE_TYPE_DESCRIPTION", "description" },
    { C_ENUM(ARV_GC_PROPERTY_NODE_TYPE_VISIBILITY), "ARV_GC_PROPERTY_NODE_TYPE_VISIBILITY", "visibility" },
    { C_ENUM(ARV_GC_PROPERTY_NODE_TYPE_TOOLTIP), "ARV_GC_PROPERTY_NODE_TYPE_TOOLTIP", "tooltip" },
    { C_ENUM(ARV_GC_PROPERTY_NODE_TYPE_DISPLAY_NAME), "ARV_GC_PROPERTY_NODE_TYPE_DISPLAY_NAME", "display-name" },
    { C_ENUM(ARV_GC_PROPERTY_NODE_TYPE_MINIMUM), "ARV_GC_PROPERTY_NODE_TYPE_MINIMUM", "minimum" },
    { C_ENUM(ARV_GC_PROPERTY_NODE_TYPE_MAXIMUM), "ARV_GC_PROPERTY_NODE_TYPE_MAXIMUM", "maximum" },
    { C_ENUM(ARV_GC_PROPERTY_NODE_TYPE_SLOPE), "ARV_GC_PROPERTY_NODE_TYPE_SLOPE", "slope" },
    { C_ENUM(ARV_GC_PROPERTY_NODE_TYPE_INCREMENT), "ARV_GC_PROPERTY_NODE_TYPE_INCREMENT", "increment" },
    { C_ENUM(ARV_GC_PROPERTY_NODE_TYPE_IS_LINEAR), "ARV_GC_PROPERTY_NODE_TYPE_IS_LINEAR", "is-linear" },
    { C_ENUM(ARV_GC_PROPERTY_NODE_TYPE_REPRESENTATION), "ARV_GC_PROPERTY_NODE_TYPE_REPRESENTATION", "representation" },
    { C_ENUM(ARV_GC_PROPERTY_NODE_TYPE_DISPLAY_NOTATION), "ARV_GC_PROPERTY_NODE_TYPE_DISPLAY_NOTATION", "display-notation" },
    { C_ENUM(ARV_GC_PROPERTY_NODE_TYPE_DISPLAY_PRECISION), "ARV_GC_PROPERTY_NODE_TYPE_DISPLAY_PRECISION", "display-precision" },
    { C_ENUM(ARV_GC_PROPERTY_NODE_TYPE_UNIT), "ARV_GC_PROPERTY_NODE_TYPE_UNIT", "unit" },
    { C_ENUM(ARV_GC_PROPERTY_NODE_TYPE_ON_VALUE), "ARV_GC_PROPERTY_NODE_TYPE_ON_VALUE", "on-value" },
    { C_ENUM(ARV_GC_PROPERTY_NODE_TYPE_OFF_VALUE), "ARV_GC_PROPERTY_NODE_TYPE_OFF_VALUE", "off-value" },
    { C_ENUM(ARV_GC_PROPERTY_NODE_TYPE_LENGTH), "ARV_GC_PROPERTY_NODE_TYPE_LENGTH", "length" },
    { C_ENUM(ARV_GC_PROPERTY_NODE_TYPE_FORMULA), "ARV_GC_PROPERTY_NODE_TYPE_FORMULA", "formula" },
    { C_ENUM(ARV_GC_PROPERTY_NODE_TYPE_FORMULA_TO), "ARV_GC_PROPERTY_NODE_TYPE_FORMULA_TO", "formula-to" },
    { C_ENUM(ARV_GC_PROPERTY_NODE_TYPE_FORMULA_FROM), "ARV_GC_PROPERTY_NODE_TYPE_FORMULA_FROM", "formula-from" },
    { C_ENUM(ARV_GC_PROPERTY_NODE_TYPE_EXPRESSION), "ARV_GC_PROPERTY_NODE_TYPE_EXPRESSION", "expression" },
    { C_ENUM(ARV_GC_PROPERTY_NODE_TYPE_CONSTANT), "ARV_GC_PROPERTY_NODE_TYPE_CONSTANT", "constant" },
    { C_ENUM(ARV_GC_PROPERTY_NODE_TYPE_ACCESS_MODE), "ARV_GC_PROPERTY_NODE_TYPE_ACCESS_MODE", "access-mode" },
    { C_ENUM(ARV_GC_PROPERTY_NODE_TYPE_IMPOSED_ACCESS_MODE), "ARV_GC_PROPERTY_NODE_TYPE_IMPOSED_ACCESS_MODE", "imposed-access-mode" },
    { C_ENUM(ARV_GC_PROPERTY_NODE_TYPE_CACHABLE), "ARV_GC_PROPERTY_NODE_TYPE_CACHABLE", "cachable" },
    { C_ENUM(ARV_GC_PROPERTY_NODE_TYPE_POLLING_TIME), "ARV_GC_PROPERTY_NODE_TYPE_POLLING_TIME", "polling-time" },
    { C_ENUM(ARV_GC_PROPERTY_NODE_TYPE_ENDIANNESS), "ARV_GC_PROPERTY_NODE_TYPE_ENDIANNESS", "endianness" },
    { C_ENUM(ARV_GC_PROPERTY_NODE_TYPE_SIGN), "ARV_GC_PROPERTY_NODE_TYPE_SIGN", "sign" },
    { C_ENUM(ARV_GC_PROPERTY_NODE_TYPE_LSB), "ARV_GC_PROPERTY_NODE_TYPE_LSB", "lsb" },
    { C_ENUM(ARV_GC_PROPERTY_NODE_TYPE_MSB), "ARV_GC_PROPERTY_NODE_TYPE_MSB", "msb" },
    { C_ENUM(ARV_GC_PROPERTY_NODE_TYPE_BIT), "ARV_GC_PROPERTY_NODE_TYPE_BIT", "bit" },
    { C_ENUM(ARV_GC_PROPERTY_NODE_TYPE_COMMAND_VALUE), "ARV_GC_PROPERTY_NODE_TYPE_COMMAND_VALUE", "command-value" },
    { C_ENUM(ARV_GC_PROPERTY_NODE_TYPE_CHUNK_ID), "ARV_GC_PROPERTY_NODE_TYPE_CHUNK_ID", "chunk-id" },
    { C_ENUM(ARV_GC_PROPERTY_NODE_TYPE_EVENT_ID), "ARV_GC_PROPERTY_NODE_TYPE_EVENT_ID", "event-id" },
    { C_ENUM(ARV_GC_PROPERTY_NODE_TYPE_VALUE_INDEXED), "ARV_GC_PROPERTY_NODE_TYPE_VALUE_INDEXED", "value-indexed" },
    { C_ENUM(ARV_GC_PROPERTY_NODE_TYPE_VALUE_DEFAULT), "ARV_GC_PROPERTY_NODE_TYPE_VALUE_DEFAULT", "value-default" },
    { C_ENUM(ARV_GC_PROPERTY_NODE_TYPE_STREAMABLE), "ARV_GC_PROPERTY_NODE_TYPE_STREAMABLE", "streamable" },
    { C_ENUM(ARV_GC_PROPERTY_NODE_TYPE_P_UNKNONW), "ARV_GC_PROPERTY_NODE_TYPE_P_UNKNONW", "p-unknonw" },
    { C_ENUM(ARV_GC_PROPERTY_NODE_TYPE_P_FEATURE), "ARV_GC_PROPERTY_NODE_TYPE_P_FEATURE", "p-feature" },
    { C_ENUM(ARV_GC_PROPERTY_NODE_TYPE_P_VALUE), "ARV_GC_PROPERTY_NODE_TYPE_P_VALUE", "p-value" },
    { C_ENUM(ARV_GC_PROPERTY_NODE_TYPE_P_ADDRESS), "ARV_GC_PROPERTY_NODE_TYPE_P_ADDRESS", "p-address" },
    { C_ENUM(ARV_GC_PROPERTY_NODE_TYPE_P_IS_IMPLEMENTED), "ARV_GC_PROPERTY_NODE_TYPE_P_IS_IMPLEMENTED", "p-is-implemented" },
    { C_ENUM(ARV_GC_PROPERTY_NODE_TYPE_P_IS_LOCKED), "ARV_GC_PROPERTY_NODE_TYPE_P_IS_LOCKED", "p-is-locked" },
    { C_ENUM(ARV_GC_PROPERTY_NODE_TYPE_P_IS_AVAILABLE), "ARV_GC_PROPERTY_NODE_TYPE_P_IS_AVAILABLE", "p-is-available" },
    { C_ENUM(ARV_GC_PROPERTY_NODE_TYPE_P_SELECTED), "ARV_GC_PROPERTY_NODE_TYPE_P_SELECTED", "p-selected" },
    { C_ENUM(ARV_GC_PROPERTY_NODE_TYPE_P_MINIMUM), "ARV_GC_PROPERTY_NODE_TYPE_P_MINIMUM", "p-minimum" },
    { C_ENUM(ARV_GC_PROPERTY_NODE_TYPE_P_MAXIMUM), "ARV_GC_PROPERTY_NODE_TYPE_P_MAXIMUM", "p-maximum" },
    { C_ENUM(ARV_GC_PROPERTY_NODE_TYPE_P_INCREMENT), "ARV_GC_PROPERTY_NODE_TYPE_P_INCREMENT", "p-increment" },
    { C_ENUM(ARV_GC_PROPERTY_NODE_TYPE_P_INDEX), "ARV_GC_PROPERTY_NODE_TYPE_P_INDEX", "p-index" },
    { C_ENUM(ARV_GC_PROPERTY_NODE_TYPE_P_LENGTH), "ARV_GC_PROPERTY_NODE_TYPE_P_LENGTH", "p-length" },
    { C_ENUM(ARV_GC_PROPERTY_NODE_TYPE_P_PORT), "ARV_GC_PROPERTY_NODE_TYPE_P_PORT", "p-port" },
    { C_ENUM(ARV_GC_PROPERTY_NODE_TYPE_P_VARIABLE), "ARV_GC_PROPERTY_NODE_TYPE_P_VARIABLE", "p-variable" },
    { C_ENUM(ARV_GC_PROPERTY_NODE_TYPE_P_INVALIDATOR), "ARV_GC_PROPERTY_NODE_TYPE_P_INVALIDATOR", "p-invalidator" },
    { C_ENUM(ARV_GC_PROPERTY_NODE_TYPE_P_COMMAND_VALUE), "ARV_GC_PROPERTY_NODE_TYPE_P_COMMAND_VALUE", "p-command-value" },
    { C_ENUM(ARV_GC_PROPERTY_NODE_TYPE_P_VALUE_INDEXED), "ARV_GC_PROPERTY_NODE_TYPE_P_VALUE_INDEXED", "p-value-indexed" },
    { C_ENUM(ARV_GC_PROPERTY_NODE_TYPE_P_VALUE_DEFAULT), "ARV_GC_PROPERTY_NODE_TYPE_P_VALUE_DEFAULT", "p-value-default" },
{ 0, NULL, NULL }
        };
        if (g_once_init_enter (&gtype_id)) {
            GType new_type = g_enum_register_static (g_intern_static_string ("ArvGcPropertyNodeType"), values);
            g_once_init_leave (&gtype_id, new_type);
        }
        return (GType) gtype_id;
        }

/* enumerations from "arvgvdevice.h" */

GType
arv_gv_packet_size_adjustment_get_type (void)
{
static gsize gtype_id = 0;
static const GEnumValue values[] = {
    { C_ENUM(ARV_GV_PACKET_SIZE_ADJUSTMENT_NEVER), "ARV_GV_PACKET_SIZE_ADJUSTMENT_NEVER", "never" },
    { C_ENUM(ARV_GV_PACKET_SIZE_ADJUSTMENT_ON_FAILURE_ONCE), "ARV_GV_PACKET_SIZE_ADJUSTMENT_ON_FAILURE_ONCE", "on-failure-once" },
    { C_ENUM(ARV_GV_PACKET_SIZE_ADJUSTMENT_ON_FAILURE), "ARV_GV_PACKET_SIZE_ADJUSTMENT_ON_FAILURE", "on-failure" },
    { C_ENUM(ARV_GV_PACKET_SIZE_ADJUSTMENT_ONCE), "ARV_GV_PACKET_SIZE_ADJUSTMENT_ONCE", "once" },
    { C_ENUM(ARV_GV_PACKET_SIZE_ADJUSTMENT_ALWAYS), "ARV_GV_PACKET_SIZE_ADJUSTMENT_ALWAYS", "always" },
    { C_ENUM(ARV_GV_PACKET_SIZE_ADJUSTMENT_DEFAULT), "ARV_GV_PACKET_SIZE_ADJUSTMENT_DEFAULT", "default" },
{ 0, NULL, NULL }
        };
        if (g_once_init_enter (&gtype_id)) {
            GType new_type = g_enum_register_static (g_intern_static_string ("ArvGvPacketSizeAdjustment"), values);
            g_once_init_leave (&gtype_id, new_type);
        }
        return (GType) gtype_id;
        }

GType
arv_gv_ip_configuration_mode_get_type (void)
{
static gsize gtype_id = 0;
static const GEnumValue values[] = {
    { C_ENUM(ARV_GV_IP_CONFIGURATION_MODE_NONE), "ARV_GV_IP_CONFIGURATION_MODE_NONE", "none" },
    { C_ENUM(ARV_GV_IP_CONFIGURATION_MODE_PERSISTENT_IP), "ARV_GV_IP_CONFIGURATION_MODE_PERSISTENT_IP", "persistent-ip" },
    { C_ENUM(ARV_GV_IP_CONFIGURATION_MODE_DHCP), "ARV_GV_IP_CONFIGURATION_MODE_DHCP", "dhcp" },
    { C_ENUM(ARV_GV_IP_CONFIGURATION_MODE_LLA), "ARV_GV_IP_CONFIGURATION_MODE_LLA", "lla" },
    { C_ENUM(ARV_GV_IP_CONFIGURATION_MODE_FORCE_IP), "ARV_GV_IP_CONFIGURATION_MODE_FORCE_IP", "force-ip" },
{ 0, NULL, NULL }
        };
        if (g_once_init_enter (&gtype_id)) {
            GType new_type = g_enum_register_static (g_intern_static_string ("ArvGvIpConfigurationMode"), values);
            g_once_init_leave (&gtype_id, new_type);
        }
        return (GType) gtype_id;
        }

/* enumerations from "arvgvstream.h" */

GType
arv_gv_stream_option_get_type (void)
{
static gsize gtype_id = 0;
static const GEnumValue values[] = {
    { C_ENUM(ARV_GV_STREAM_OPTION_NONE), "ARV_GV_STREAM_OPTION_NONE", "none" },
    { C_ENUM(ARV_GV_STREAM_OPTION_PACKET_SOCKET_DISABLED), "ARV_GV_STREAM_OPTION_PACKET_SOCKET_DISABLED", "packet-socket-disabled" },
{ 0, NULL, NULL }
        };
        if (g_once_init_enter (&gtype_id)) {
            GType new_type = g_enum_register_static (g_intern_static_string ("ArvGvStreamOption"), values);
            g_once_init_leave (&gtype_id, new_type);
        }
        return (GType) gtype_id;
        }

GType
arv_gv_stream_socket_buffer_get_type (void)
{
static gsize gtype_id = 0;
static const GEnumValue values[] = {
    { C_ENUM(ARV_GV_STREAM_SOCKET_BUFFER_FIXED), "ARV_GV_STREAM_SOCKET_BUFFER_FIXED", "fixed" },
    { C_ENUM(ARV_GV_STREAM_SOCKET_BUFFER_AUTO), "ARV_GV_STREAM_SOCKET_BUFFER_AUTO", "auto" },
{ 0, NULL, NULL }
        };
        if (g_once_init_enter (&gtype_id)) {
            GType new_type = g_enum_register_static (g_intern_static_string ("ArvGvStreamSocketBuffer"), values);
            g_once_init_leave (&gtype_id, new_type);
        }
        return (GType) gtype_id;
        }

GType
arv_gv_stream_packet_resend_get_type (void)
{
static gsize gtype_id = 0;
static const GEnumValue values[] = {
    { C_ENUM(ARV_GV_STREAM_PACKET_RESEND_NEVER), "ARV_GV_STREAM_PACKET_RESEND_NEVER", "never" },
    { C_ENUM(ARV_GV_STREAM_PACKET_RESEND_ALWAYS), "ARV_GV_STREAM_PACKET_RESEND_ALWAYS", "always" },
{ 0, NULL, NULL }
        };
        if (g_once_init_enter (&gtype_id)) {
            GType new_type = g_enum_register_static (g_intern_static_string ("ArvGvStreamPacketResend"), values);
            g_once_init_leave (&gtype_id, new_type);
        }
        return (GType) gtype_id;
        }

/* enumerations from "arvstream.h" */

GType
arv_stream_callback_type_get_type (void)
{
static gsize gtype_id = 0;
static const GEnumValue values[] = {
    { C_ENUM(ARV_STREAM_CALLBACK_TYPE_INIT), "ARV_STREAM_CALLBACK_TYPE_INIT", "init" },
    { C_ENUM(ARV_STREAM_CALLBACK_TYPE_EXIT), "ARV_STREAM_CALLBACK_TYPE_EXIT", "exit" },
    { C_ENUM(ARV_STREAM_CALLBACK_TYPE_START_BUFFER), "ARV_STREAM_CALLBACK_TYPE_START_BUFFER", "start-buffer" },
    { C_ENUM(ARV_STREAM_CALLBACK_TYPE_BUFFER_DONE), "ARV_STREAM_CALLBACK_TYPE_BUFFER_DONE", "buffer-done" },
{ 0, NULL, NULL }
        };
        if (g_once_init_enter (&gtype_id)) {
            GType new_type = g_enum_register_static (g_intern_static_string ("ArvStreamCallbackType"), values);
            g_once_init_leave (&gtype_id, new_type);
        }
        return (GType) gtype_id;
        }

/* enumerations from "arvxmlschema.h" */

GType
arv_xml_schema_error_get_type (void)
{
static gsize gtype_id = 0;
static const GEnumValue values[] = {
    { C_ENUM(ARV_XML_SCHEMA_ERROR_INVALID_STRUCTURE), "ARV_XML_SCHEMA_ERROR_INVALID_STRUCTURE", "structure" },
{ 0, NULL, NULL }
        };
        if (g_once_init_enter (&gtype_id)) {
            GType new_type = g_enum_register_static (g_intern_static_string ("ArvXmlSchemaError"), values);
            g_once_init_leave (&gtype_id, new_type);
        }
        return (GType) gtype_id;
        }

/* Generated data ends here */

